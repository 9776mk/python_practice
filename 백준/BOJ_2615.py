from pprint import pprint

field = []
N = 19
black_ = 1
white_ = 2

# 바둑판 입력 받음
for _ in range(N):
    field.append(list(map(int, input().split())))
#pprint(field) 

# field = [
# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 1, 2, 0, 0, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

# 바둑판 델타 탐색
# 4가지 경우
# 1  1   11111    1
# 1   1          1
# 1    1        1
# 1     1      1
# 1      1    1 

# 가장 왼쪽, 혹은 가장 위의 바둑알을 출력해야 하므로
# 우, 하, 우상, 우하 델타 검색이 일어나야함
dx = [1, 0, 1, 1]
dy = [0, 1, -1, 1]

is_found = False

# 모든 바둑판 x,y에 대해서
for x in range(N):
    for y in range(N):
        # 좌표값이 흰색 혹은 검은색 돌일 경우에
        #print(f'델타 탐색 시작 좌표 : {x},{y}')
        if field[x][y] == black_ or field[x][y] == white_:
            # 첫 번째 돌로 설정
            stone_cnt = 1
            
            # 델타 탐색 진행
            for i in range(4):
                nx = x + dx[i]
                ny = y + dy[i]

                while True:
                # 새로운 nx, ny가 범위를 벗어나지 않고, 색깔이 같으면 cnt +1 하고 같은 방향으로 계속 진행
                    if -1 < nx < N and -1 < ny < N and field[x][y] == field[nx][ny]:
                        stone_cnt += 1
                        #print(stone_cnt)
                        nx = nx + dx[i]
                        ny = ny + dy[i]
                        
                        #print(f'델타 탐색 현재 좌표 : {nx},{ny}')

                        # 돌이 5개이면
                        if stone_cnt == 5:
                            # 6목 검사를 해서 6목이 아닌 경우 x, y 를 출력
                            # 6목 검사는 시작한 x,y에서 -델타 탐색 방향과 5목에 해당 되는 곳에서 한 번 더 델타 탐색
                                # 델타 탐색을 한 후 조건을 만족하면 break 문으로 빠져 나가면 되므로 한 번 더 델타 탐색은 하지 않아도 됨
                            nx_0, ny_0 = x - dx[i], y - dy[i]
                            #print(nx_0, ny_0)

                            # nx_0, ny_0가 바둑판을 벗어났거나 색깔이 다르다면 5목
                            if not(-1 < nx_0 < N and -1 < ny_0 < N ) or field[nx_0][ny_0] != field[x][y]:
                                print(field[x][y])
                                print(x+1, y+1)
                                is_found = True
                                break
                    # 범위를 벗어나거나 색깔이 다른 경우 새로운 델타 탐색        
                    else:
                        break
                    
        if is_found:
            break

if is_found == False:
    print(0)